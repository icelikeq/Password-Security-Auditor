import re
import getpass
from collections import Counter

# --- Configuration and Rules ---

# Define the minimum requirements for a "Strong" password
MIN_LENGTH = 12
REQUIRED_COMPLEXITY = 3  # Number of required character types (upper, lower, digit, symbol)

# A small blacklist of common passwords (replace with a hashed, large list in a production environment)
COMMON_PASSWORDS = {
    "password", "123456", "qwerty", "admin", "hello", "secret", 
    "master", "welcome", "starter", "dragon", "baseball"
}

# Define score weights (higher weight means a more severe flaw)
WEIGHTS = {
    "length": 1,
    "complexity": 2,
    "blacklist": 10,  # Highest penalty for known breached passwords
    "repetition": 3,
    "sequence": 3,
}

# --- Utility Functions ---

def analyze_complexity(password):
    """
    Checks for the presence of different character types.
    Returns a dictionary of boolean flags and a complexity score.
    """
    checks = {
        'has_lower': bool(re.search(r'[a-z]', password)),
        'has_upper': bool(re.search(r'[A-Z]', password)),
        'has_digit': bool(re.search(r'\d', password)),
        'has_symbol': bool(re.search(r'[!@#$%^&*()_+={}\[\]:;"\'<,>.?/\\|~`]', password)),
    }
    checks['score'] = sum(checks.values())
    return checks

def check_repetition(password):
    """
    Checks for long sequences of repeating characters (e.g., 'aaaaa').
    Returns a set of warnings if repetition is detected.
    """
    warnings = set()
    # Check for 4 or more consecutive identical characters
    if re.search(r'(.)\1{3,}', password):
        warnings.add("Excessive character repetition detected.")
    
    # Check for common dictionary words as a general repetition/pattern check (Simplified)
    # A more advanced audit would use entropy calculations.
    
    return warnings

def check_sequences(password):
    """
    Checks for common keyboard or numeric sequences (e.g., '1234' or 'asdf').
    Returns a set of warnings if a sequence is detected.
    """
    warnings = set()
    
    # Check for numeric sequences (4 or more digits)
    if re.search(r'0123|1234|2345|3456|4567|5678|6789', password, re.IGNORECASE) or \
       re.search(r'9876|8765|7654|6543|5432|4321|3210', password, re.IGNORECASE):
        warnings.add("Sequential numbers (e.g., '1234') detected.")

    # Check for common keyboard sequences (simplified)
    # Common sequences: 'qwer', 'asdf', 'zxcv'
    if re.search(r'qwer|asdf|zxcv|edcx|rfvb|tgbn', password, re.IGNORECASE):
         warnings.add("Sequential keyboard characters (e.g., 'asdf') detected.")
         
    return warnings

# --- Main Auditor Function ---

def audit_password(password):
    """
    Audits the given password against a set of rules and generates a security score and report.
    """
    report = {
        'score': 100,  # Start at 100 and subtract points for flaws
        'flaws': [],
        'suggestions': [],
        'password': password
    }

    # 1. Length Check
    if len(password) < MIN_LENGTH:
        report['score'] -= (MIN_LENGTH - len(password)) * WEIGHTS['length']
        report['flaws'].append(f"Length is only {len(password)}. Required minimum: {MIN_LENGTH}.")
        report['suggestions'].append(f"Increase password length to at least {MIN_LENGTH} characters.")

    # 2. Complexity Check
    complexity = analyze_complexity(password)
    if complexity['score'] < REQUIRED_COMPLEXITY:
        penalty = (REQUIRED_COMPLEXITY - complexity['score']) * WEIGHTS['complexity']
        report['score'] -= penalty
        report['flaws'].append(f"Low complexity score: {complexity['score']}/4 character types.")
        
        missing_types = []
        if not complexity['has_lower']: missing_types.append("lowercase letters")
        if not complexity['has_upper']: missing_types.append("uppercase letters")
        if not complexity['has_digit']: missing_types.append("numbers")
        if not complexity['has_symbol']: missing_types.append("symbols")
        
        if missing_types:
            report['suggestions'].append(f"Add missing character types: {', '.join(missing_types)}.")

    # 3. Blacklist Check
    if password.lower() in COMMON_PASSWORDS:
        report['score'] -= WEIGHTS['blacklist']
        report['flaws'].append("Password found in the list of commonly used/breached passwords.")
        report['suggestions'].append("Choose a unique password that is not widely used.")

    # 4. Repetition Check
    repetition_warnings = check_repetition(password)
    if repetition_warnings:
        report['score'] -= WEIGHTS['repetition'] * len(repetition_warnings)
        report['flaws'].extend(repetition_warnings)
        report['suggestions'].append("Avoid using long sequences of the same character (e.g., 'aaaa').")

    # 5. Sequence Check
    sequence_warnings = check_sequences(password)
    if sequence_warnings:
        report['score'] -= WEIGHTS['sequence'] * len(sequence_warnings)
        report['flaws'].extend(sequence_warnings)
        report['suggestions'].append("Avoid using common numeric or keyboard sequences (e.g., '1234', 'asdf').")

    # Final Score Normalization and Grading
    report['score'] = max(0, report['score'])  # Ensure score is not negative

    if report['score'] >= 80:
        report['grade'] = "Excellent (A+)"
    elif report['score'] >= 60:
        report['grade'] = "Strong (B)"
    elif report['score'] >= 40:
        report['grade'] = "Moderate (C)"
    else:
        report['grade'] = "Weak (D/F)"

    return report

# --- User Interface and Execution ---

def print_report(report):
    """
    Prints the audit report in a formatted, user-friendly way.
    """
    print("\n" + "="*50)
    print(f"| PASSWORD AUDIT REPORT (Score: {report['score']} / 100) |")
    print("="*50)
    print(f"SECURITY GRADE: \033[1m{report['grade']}\033[0m") # Bold grade

    print("\n--- DETECTED FLAWS ---")
    if report['flaws']:
        for i, flaw in enumerate(report['flaws'], 1):
            print(f"  [{i}] \033[91mFAIL:\033[0m {flaw}") # Red Fail
    else:
        print("  \033[92mPASS:\033[0m No significant flaws detected.") # Green Pass

    print("\n--- IMPROVEMENT SUGGESTIONS ---")
    if report['suggestions']:
        # Use a set to display unique suggestions only
        unique_suggestions = sorted(list(set(report['suggestions'])))
        for i, suggestion in enumerate(unique_suggestions, 1):
            print(f"  [{i}] {suggestion}")
    else:
        print("  The password meets all baseline security criteria.")
    
    print("="*50 + "\n")


if __name__ == "__main__":
    print("--- Password Security Auditor ---")
    print("Enter a password to audit its strength (input is hidden).")

    while True:
        try:
            # getpass hides the user input for security
            user_password = getpass.getpass("Enter password (or 'exit' to quit): ")
            
            if user_password.lower() == 'exit':
                break
            
            if not user_password:
                print("Input cannot be empty. Please try again.")
                continue

            audit_result = audit_password(user_password)
            print_report(audit_result)

        except Exception as e:
            print(f"An error occurred: {e}")
            break

    print("Auditor closed. Thank you!")